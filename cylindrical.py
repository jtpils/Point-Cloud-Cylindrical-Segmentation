import pcl
cloud = pcl.load("table_scene_mug_stereo_textured.pcd")
print('PointCloud has: ' + str(cloud.size) + ' data points.')
passthrough = cloud.make_passthrough_filter()
passthrough.set_filter_field_name ('z')
passthrough.set_filter_limits (0, 1.5)
cloud_filtered = passthrough.filter()
print('PointCloud has: ' + str(cloud_filtered.size) + ' data points.')
ne = cloud_filtered.make_NormalEstimation()
tree = cloud_filtered.make_kdtree()
ne.set_SearchMethod (tree)
ne.set_KSearch (50)
seg = cloud_filtered.make_segmenter_normals(ksearch=50)
seg.set_optimize_coefficients (True)
seg.set_model_type (pcl.SACMODEL_NORMAL_PLANE)
seg.set_normal_distance_weight (0.1)
seg.set_method_type (pcl.SAC_RANSAC)
seg.set_max_iterations (100)
seg.set_distance_threshold (0.03)
[inliers_plane, coefficients_plane] = seg.segment ()
cloud_plane = cloud_filtered.extract(inliers_plane, False)
print('PointCloud representing the planar component: ' + str(cloud_plane.size) + ' data points.\n')
pcl.save(cloud_plane, 'table_scene_mug_stereo_textured_plane.pcd')
cloud_filtered2 = cloud_filtered.extract(inliers_plane, True)
seg = cloud_filtered2.make_segmenter_normals(ksearch=50)
seg.set_optimize_coefficients (True)
seg.set_model_type (pcl.SACMODEL_CYLINDER)
seg.set_normal_distance_weight (0.1)
seg.set_method_type (pcl.SAC_RANSAC)
seg.set_max_iterations (10000)
seg.set_distance_threshold (0.05)
seg.set_radius_limits (0, 0.1)
[inliers_cylinder, coefficients_cylinder] = seg.segment ()
cloud_cylinder = cloud_filtered2.extract(inliers_cylinder, False)
if cloud_cylinder.size == 0:
    print("Can't find the cylindrical component.")
else:
    print("PointCloud representing the cylindrical component: " + str(cloud_cylinder.size) + " data points.")
    pcl.save(cloud_cylinder, 'table_scene_mug_stereo_textured_cylinder.pcd')
